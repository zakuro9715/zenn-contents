---
title: '2021/02/27 - Generics の誤判定を減らした / コンパイラが命名規則を利用するのは合理的'
---

[Generics の実装が雑](https://zenn.dev/zakuro9715/books/vlang-dev-diary/viewer/2021-02-25-generics-implementation) で書いたとおり、V 言語は Generics の構文解析がうまくできていなかった。このときに `f<mod.Type>` をパースできないという問題は直したが、書いたとおり `return a < b, c > d` みたいなものを Generics と誤判定するバグは残っていた。

この日誌には以下のようなことが書いてある。

> 今この日誌を書いていていくつかの改善を思いついた。V 言語では組み込み型以外の型名は大文字から始まるし、変数名やフィールド名に大文字は使えない。このあたりを利用すれば、もう少し正確な判定が実装できそうだ。

これは本当にその時の思いつきだったが、考えた結果実際に使えそうだということで実装し、マージされた。

[parser: imporve generics detection #8992](https://github.com/vlang/v/pull/8992)

この実装では、パーサの時点でわかっている型(=組み込み型)と大文字から始まる名前を型として判定し、`a < b, c > d` のパターンについては `<` の後ろが型だった場合に Generics と判定している。ただし、`a<b>` の場合は型かどうかに関わらず Generics と判定する。この場合結局エラーにはなるのだが、比較演算子だと判定するとエラーメッセージがわかりづらくなるためだ。

ところで、これは V言語の命名規則によって可能になっている。V言語では struct の名前は先頭大文字かつに文字以上、変数名は小文字、Generics の型パラメータは大文字1文字など、いくつかの規則が存在する。これらは推奨ではなく構文上必須であり、守らない場合はコンパイルが通らないようになっている。Go言語では先頭が大文字かどうかで public / private が決まるのと似ている。

Go言語のその規則は最初かなり不思議に思ったが、実際のところ命名規則に言語上の意味をもたせるというのはかなり良いアプローチに思える。どの言語を使おうともなにかしらの命名規則は使うのだから、コンパイラがその情報を使わないのはもったいない。

とはいえ、Generics に `<>` を使うのは筋が良くないという意見に代わりはない。今回のことにしても、私が気づくまでだれも気づいておらずたまたま利用できたというだけだ。型名は大文字から始めるから Generics に `<>` を使っても `a < b, c > d` を判別できる、というような考察をして記号を決定していたわけではない（実際そうなってなかったんだし）。典型的な `>>` の問題も残っている

[ちなみに Go の proposal ではそのあたりのことは当然のように考慮されている。](https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md#why-not-use-the-syntax-like-c_and-java)

実際のところ私も Generics の構文をそれほど深く考察したわけではないので、まだまだエッジケースがあると思われる。わかりやすいところでは、`Foo<Foo<int>>` は正しくパースできない。

```
>>> struct Foo<T> {}
>>> Foo<int>{}
Foo<int>{}
>>> Foo<Foo<int>>{}
error: unexpected token `>>`, expecting `>`
    8 |
    9 | }
   10 | println(Foo<Foo<int>>{
      |                    ~~
   11 |
   12 | })
>>>
```
