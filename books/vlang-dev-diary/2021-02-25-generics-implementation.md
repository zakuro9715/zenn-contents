---
title: "2021/02/25 - ジェネリクスの実装が雑"
---

V のジェネリクスの実装はかなりいい加減。一応実装はされているし、動くことには動く。だがかゆいところには手が届かない。

例えば、パターンマッチや smartcast は動かない。

```
interface Any {}
fn f_match<T>(v Any) ?T {
    match v {
        T { v } // エラー
        else { none }
    }
}

fn f_is<T>(v Any) ?T {
    if v is T {  // エラー
        return v
    }
    return none
}
```

T に対する copmile-time reflection は多少便利。

```
fn to_str_lit<T>(v T) string {
    mut res := v.str()
    $if T is string {
        res = "'$res'"
    }
    return res
}
```

## ジェネリクスと比較演算子の判別

ありがちなことだが、`f<int>` 構文を採用したせいで、構文解析がうまくできておらず、書き方によっては比較演算子と誤判定される。
この判定の実装は、簡単に言ってしまえば、`<` のあとに続くトークン列を見てなんとなくジェネリクスっぽいかという判定。`>` があるかは確認していない。この時点では関数の定義情報などは持っていないので、トークンの種類のみで判定している。

```
f < x >  // ジェネリクス
f < x +  // たぶん f < x + 1 とかでジェネリクスではなさそう
f < x,   // f < x , y > みたいなジェネリクスっぽい
```

上の例を見て考えるとわかるが、たとえばこういうのは落ちる。

```
return f < x, 0  // `f < x ,` を見た時点でジェネリクスだと思いこむ
```

これに関連して、1つ PR を出した([parser: Treat f<mod.name> as generic call not `<` operator](https://github.com/vlang/v/pull/8938))。この PR がマージされれば、`f<mod.Type>` がちゃんと動くようになる（これを使おうとして動かなかったときは、本当に何が原因かわからず、AST とパーサとにらめっこしていた）。

今この日誌を書いていていくつかの改善を思いついた。V 言語では組み込み型以外の型名は大文字から始まるし、変数名やフィールド名に大文字は使えない。このあたりを利用すれば、もう少し正確な判定が実装できそうだ。

## 構造体のジェネリクス

最近実験的に導入されたから仕方ないとはいえ、構造体のジェネリクスはほとんど意味がないレベルでなにもできない。型パラメータが使える箇所はフィールドの型くらいしかない。

```v
struct Foo<T> {
}
struct Bar<T> {
    t T         // これはつかえる。Tは実際の型に展開される
    list []T    // これはダメ。T が T という名前の型として、Cのコード生成まで残る。当然 T という型の定義はないので、Cのコンパイルで落ちる。
    foo Foo<T>  // 同じ理由でこれもダメ
}

fn (bar Bar<T>) f() {} // これも一緒

fn (bar Bar<int>) f2() {} // こういう書き方はできる
```

## どうしてこんなことになっているのか

どうしてジェネリクスの実装が適当なのか。おそらく単にV言語コンパイラとその周辺ツールがジェネリクスを使っていないからだろう。ジェネリクスに限らずだが、コンパイラが使っていない機能の実装は後回しにされがちだ。

## ジェネリクスの構文について

ジェネリクスの構文は、`f<int>` のように `<>` を使う形式が一般的だ。だが、これはよく考えてみると非常に筋が良くないアプローチである。
比較演算子と記号が被るのはまだ良いが、最大の問題は、比較演算子は括弧ではないので、`<` に対応する `>` が存在するとは限らないことだ。加えて、C++ で有名な `vecotr<vecotr<int>>` が動かない問題もある（これはもう解決したんでしたっけ）。

とにかく、この構文はコンパイラに優しくない。

そう考えてみると、Go がジェネリクスに `[]` を選択したのは非常に合理的だ。こういうところはさすが Go、やはりセンスが良い。

しかし、もはや `<>` の構文が浸透してしまったのは事実で、その点で Go の構文には見た目上の違和感は存在する。この構文はプログラミング言語における負の遺産ではないだろうか。

